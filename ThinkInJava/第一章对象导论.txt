
由于最近的学习中发现对java基础部分的掌握不是很好 所以决定对《java编程思想（第四版）》进行再一次的学习，过程中参考《java开发实战经典》，因为这本书讲的相对更容易理解一些，文章是通过对以前学习编程思想的笔记进行扩展写的。一些常见的问题也会尽量写在文章中。

一.对象

    1.万物皆对象：将对象视为变量，可以存储数据，还可以在自身上执行操作
    2.程序是对象的集合，对象之间发送消息：消息可以理解为对某个特定对象的调用请求
    3.每个对象都有自己的由其他对象所构成的存储：可以通过创建现有对象的包的方式来创建新的对象
    4.每个对象都有其类型：每个对象都是某个类的一个实例，类就是对象的类型，每个类最重要区别于别的类的特性是“可以发送什么样的消息给他”
    5.某个特定类型的所有对象都可以接受相同的消息，对于这一点很好理解，对象都是某个类的实例，所以每个对象有相同的方法。

    Booch对对象提出了一个更加简洁的描述：对象具有状态，行为，标识，这意味着每一个对象可以拥有内部数据和方法，并且每一个对象可以唯一的与其他对象区分开来，也就是说每一个对象在内存中都有唯一的地址。


二.每个对象都有一个接口

    接口确定了某一特定对象所能发出的请求，但是在程序中必须有满足这些请求的代码，这些代码与隐藏的数据一起构成了实现。

    这里的接口不是指我们平时所使用的interface 而是说每个对象都有一个对外的方法（请求）

 


三.每个对象都提供服务
     正在试图开发或者理解一个程序设计的时候，可以将对象想象为“服务提供者”，程序向用户提供服务，它将通过调试其他对象提供的服务来实现这一目的，开发的目标就是去创建能够提供理想服务来解决问题的一系列对象。

    将对象看作是服务的提供者还有一个附带的好处：有助于提高对象的内聚性，高内聚是软件设计的基本要求之一（这意味着一个软件构件的各个方面组合的很好）

四.被隐藏的具体实现
    通常会将开发人员按照角色分类为类创建者和客户端程序员  

    客户端程序员目标是手机各种用来实现快速应用开发的类 类创建者的目标是构建类 这中类只向客户端程序员暴露必须的部分而隐藏其他部分，因为如果加以隐藏，那么客户端程序员将不能访问他，而类创建者可以任意修改被隐藏的部分，而不需要担心对别人造成影响，因为被隐藏的部分通常代表对象内部脆弱的部分。容易被不知情的程序员毁坏

    访问权限控制的第一个原因就是让客户端程序员不接触他们不应该触及的部分-- 这部分对数据类型的内部操作是必须的，但不是用户解决特定问题所需要的接口的一部分。

    第二个原因是允许库的设计者可以改变类的内部工作方式二不用担心会影响到客户端程序员

    java用三个关键字来在类的内部设定边界：

    public ：表示紧随其后的元素对任何人都是可用的

    private ： 表示出了类型创建者和类型内部方法之外的任何人都不可以访问

    protected ： 作用与private相当，差别仅在于集成的类可以访问protected的成员但是不能访问private的成员

    包访问权限：也是java的默认访问权限，当没有使用前面提到的关键词时，它将发挥作用，在这种权限下类可以访问在同一个包下的其他类的成员，但是在包之外相当于指定了private。


五.复用

    1.理想情况下一个创建并测试完的类代表一个有用的代码单元  
    2.使用现有的类合成一个新的类，这种概念被称为组合，如果组合是动态发生的通常被称之为聚合，组合被视为“has-a（拥有）”关系
    3.新类的成员对象通常被声明为private使使用新类的客户端程序员不能访问他们

六.继承
 
    类型不仅只会描述了作用于一个对象集合上的约束条件，同时还有与其他类型之间的关系，两个类型可以有相同的特性和行为，但是其中一个类型可能比另一个含有更多的特性，并且可以处理更多的消息。



七.是一个和像是一个的关系  
    如果继承只覆盖基类的方法，而不添加基类中完全没有的方法，就意味着导出类和基类是完全相同的类型，因为他们有完全相同的接口，结果是可以用一个导出类的对象来替代一个基类对象， 这可以被视为纯粹替代，通常称之为替代原则  ，在某种意义上这是一种继承的理想方式，将这种情况称之为is-a关系 因为可以说“一个原型是一个几何形状”。

    有时必须在新类中添加新的方法，这样也就扩展了接口，这个类型仍然可以代替基类，但是这种替代并不完美，因为基类不可以访问新添加的方法。这种情况可以描述为 is-like-a 关系，新类具有旧类的接口，但是还包含其他方法，所以不能说他们完全相同。

八.伴随多态的可互换对象
    后期绑定：当向对象发送消息时，被调用的代码直到运行才能确定。编译器确保被调用的方法的存在，并对调用参数和返回值类型进行检查，但是不知道被执行的确切代码。

    为了执行后期绑定java使用了一小段特殊的代码来替代绝对地址调用，这段代码使用在对象中存储的信息来计算方法体的地址（后期更新会写到），这样根据这一小段代码得内容，每一个对象都可以具有不同的行为表现，当向一个对象发送消息的时候，对象就能知道应该执行什么操作。

 

九.单根继承
    java中所有的类最终都继承自单一的基类，Object

    在单根继承结构中所有对象都具有一个共用的接口，所以他们归根结底是相同的基本类型

    单根继承保证所有对象都具备某些功能，因此你知道在你的系统中可以再每个对象上执行某些基本操作，所有的对象都可以很容易的在堆上进行创建，而且传递参数也得到了极大的简化。

    单根继承结构使垃圾回收器的实现变得容易很多，而垃圾回收正是java相对C++的重要改进之一。由于所有对象都要保证具有其类型信息，因此不会因无法确定对象的类型而陷入僵局。这对于系统级的操作显得尤为重要，并且给标称带来了更大的灵活性。

 

十.容器
    通常来说，如果不知道在解决某个特定问题时需要多少个对象，或者它们将存活多久，那么就不可能知道如何存储这些对象。

    在面向对象设计中的大多数问题而言，解决方案是：创建另一种对象类型，这种新的对象类型持有对其他类型的引用，当然你可以在大多数语言中都有的数组来实现相同的功能，但是这个通常被称之为容器。在新对象中，在任何需要的时候都可以扩充自己以容纳你置于其中的所有东西，因此不需要知道将来会把多少个对象置于容器中，只需要创建一个容器对象，然后让它处理所有的细节。

 

十一.参数化类型（泛型）
    在se5出现之前，容器存储的对象都只具有java中的通用类型，Object 单根继承意味着所有的东西都是Object类型。所以存储Object的容器可以存储任何东西，这使得容器很容易被复用，但是在存入时容器只存储Object类型，所以对象引用置入容器时，都会被向上转型成Object，因此会丢失其身份，在把它取出时，就获得了一个对Object的引用，而不是置入容器的对象的引用，这个时候回向下转换成更为具体的类型，这中转型的方式称之为向下转型，向上转型是安全的，向下转型除非知道所需要处理的具体类型，否则向下转型几乎是不安全的。

    然而向下转型并非是彻底危险的，如果向下转为错误的类型，就会得到被称之为异常的运行时错误。

    java se5的重大变化之一是增加了参数化类型，在java中它称之为泛型，一对尖括号中存储类型信息，通过这些特征就可以识别对泛型的使用。


--------------------- 
作者：SihgYu 
来源：CSDN 
原文：https://blog.csdn.net/qq_37866486/article/details/89339254 
版权声明：本文为博主原创文章，转载请附上博文链接！